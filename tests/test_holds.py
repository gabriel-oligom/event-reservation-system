import time
from datetime import datetime, timezone
import pytest

# ----- HELPERS -----
"""
These functions act as 'shortcuts' to avoid repeating code
"""

# Creates a new event with a given name and number of seats
def create_event(client, name="Test Event", total_seats=5):
    r = client.post("/events", json={"name": name, "total_seats": total_seats})
    assert r.status_code == 201, f"create_event failed: {r.status_code} {r.text}"
    return r.json()


# Retrieves all seats for a specific event
def get_seats(client, event_id):
    r = client.get(f"/events/{event_id}/seats")
    assert r.status_code == 200, f"get_seats failed: {r.status_code} {r.text}"
    return r.json()


# Places a temporary hold on a seat for a user
def post_hold(client, event_id, seat_id, user_id, seconds=60):
    r = client.post(f"/events/{event_id}/seats/{seat_id}/hold/", json={"user_id": user_id, "seconds": seconds})
    return r


# Refreshes an existing hold to extend its duration
def put_refresh_hold(client, event_id, seat_id, user_id, seconds=60):
    r = client.put(f"/events/{event_id}/seats/{seat_id}/hold/", json={"user_id": user_id, "seconds": seconds})
    return r


# Cancels a hold on a seat (only by the user who placed it)
def delete_hold(client, event_id, seat_id, user_id):
    r = client.delete(f"/events/{event_id}/seats/{seat_id}/hold/", json={"user_id": user_id})
    return r


# Attempts to reserve a seat for a user (requires active hold)
def post_reservation(client, event_id, seat_id, user_id):
    r = client.post(f"/events/{event_id}/seats/{seat_id}/reservation/", json={"user_id": user_id})
    return r


# ----- TESTS -----

def test_create_hold_and_expire(client):
    """
    Create an event, create a short-lived hold (1s), check seat becomes 'on_hold', wait for expiry, then confirm seat becomes 'available' again
    """
    event = create_event(client, total_seats=2)
    event_id = event["id"] # extracts the event ID generated by the system (from the event class with id, name, total_seats)

    # sends a simulated POST request to hold seat 1 for user-a for 1 second, using event ID from earlier
    r = post_hold(client, event_id, seat_id=1, user_id="user-a", seconds=1)
    assert r.status_code == 201, f"hold create failed: {r.status_code} {r.text}"

    # fetches all seats for the event
    seats = get_seats(client, event_id)
    
    # finds seat number 1 from the list of seats (next() returns the first match found)
    seat1 = next(s for s in seats if s["number"] == 1)

    # asserts that number 1 iss currently on hold
    assert seat1["status"] == "on_hold", f"expected on_hold, got {seat1}"

    # wait for hold to expire and trigger expire-on-access
    time.sleep(2)

    # verify if the seat becomes "available" after the hold expires
    seats = get_seats(client, event_id)
    seat1_after = next(s for s in seats if s["number"] == 1)
    assert seat1_after["status"] == "available", "hold should have expired and seat become available"


def test_refresh_hold_extends_expiry(client):
    """
    Create a short hold, refresh it before expiry, and verify it remains on_hold
    """
    event = create_event(client, total_seats=2)
    event_id = event["id"]

    # holds seat 1 for user-b for 1 second and checks if the request succeeded
    r = post_hold(client, event_id, seat_id=1, user_id="user-b", seconds=1)
    assert r.status_code == 201

    # refreshes the hold to extend its duration to 3 seconds and checks for success
    r2 = put_refresh_hold(client, event_id, seat_id=1, user_id="user-b", seconds=3)
    assert r2.status_code == 200, f"refresh failed: {r2.status_code} {r2.text}"

    # wait less than the refreshed time
    time.sleep(2)

    # verify if the seat is still "on_hold" after the refresh
    seats = get_seats(client, event_id)
    seat1 = next(s for s in seats if s["number"] == 1)
    assert seat1["status"] == "on_hold", "hold should have been refreshed and still be active"


def test_limit_holds_per_user(client):
    """
    Enforce the per-user-per-event hold limit (limit = 3)
    Attempts to hold more should return 409
    """
    # maximum number of holds allowed per user for this test
    LIMIT = 3

    # creates an event with 6 seats and stores its ID
    event = create_event(client, total_seats=6)
    event_id = event["id"]

    # loops through seat IDs 1 to 3 to hold each one for the same user (limit is 3)
    for i in range(1, LIMIT + 1):
        r = post_hold(client, event_id, seat_id=i, user_id="user-c", seconds=60)
        assert r.status_code == 201, f"expected 409 for exceeding holds, got {r.status_code} {r.text}"

    # this one should fail (exceeds limit)
    r = post_hold(client, event_id, seat_id=LIMIT+1, user_id="user-c", seconds=60)
    assert r.status_code == 409, f"expected 409 for exceeding holds, got {r.status_code} {r.text}"