import time
from datetime import datetime, timezone
import pytest

# ----- helpers -----
"""
These functions act as 'shortcuts' to avoid repeating code
"""

# Creates a new event with a given name and number of seats
def create_event(client, name="Test Event", total_seats=5):
    r = client.post("/events", json={"name": name, "total_seats": total_seats})
    assert r.status_code == 201, f"create_event failed: {r.status_code} {r.text}"
    return r.json()


# Retrieves all seats for a specific event
def get_seats(client, event_id):
    r = client.get(f"/events/{event_id}/seats")
    assert r.status_code == 200, f"get_seats failed: {r.status_code} {r.text}"
    return r.json()


# Places a temporary hold on a seat for a user
def post_hold(client, event_id, seat_id, user_id, seconds=60):
    r = client.post(f"/events/{event_id}/seats/{seat_id}/hold/", json={"user_id": user_id, "seconds": seconds})
    return r


# Refreshes an existing hold to extend its duration
def put_refresh_hold(client, event_id, seat_id, user_id, seconds=60):
    r = client.put(f"/events/{event_id}/seats/{seat_id}/hold/", json={"user_id": user_id, "seconds": seconds})
    return r


# Cancels a hold on a seat (only by the user who placed it)
def delete_hold(client, event_id, seat_id, user_id):
    r = client.delete(f"/events/{event_id}/seats/{seat_id}/hold/", json={"user_id": user_id})
    return r


# Attempts to reserve a seat for a user (requires active hold)
def post_reservation(client, event_id, seat_id, user_id):
    r = client.post(f"/events/{event_id}/seats/{seat_id}/reservation/", json={"user_id": user_id})
    return r


# ----- tests -----

def test_create_hold_and_expire(client):
    """
    Create an event, create a short-lived hold (1s), check seat becomes 'on_hold', wait for expiry, then confirm seat becomes 'available' again
    """
    event = create_event(client, total_seats=2)
    event_id = event["id"] # extracts the event ID generated by the system (from the event class with id, name, total_seats)

    # sends a simulated POST request to hold seat 1 for user-a for 1 second, using event ID from earlier
    r = post_hold(client, event_id, seat_id=1, user_id="user-a", seconds=1)
    assert r.status_code == 201, f"hold create failed: {r.status_code} {r.text}"

    # fetches all seats for the event
    seats = get_seats(client, event_id)
    
    # finds seat number 1 from the list of seats (next() returns the first match found)
    seat1 = next(s for s in seats if s["number"] == 1)

    # asserts that number 1 iss currently on hold
    assert seat1["status"] == "on_hold", f"expected on_hold, got {seat1}"

    # wait for hold to expire and trigger expire-on-access
    time.sleep(2)

    # verify if the seat becomes "available" after the hold expires
    seats = get_seats(client, event_id)
    seat1_after = next(s for s in seats if s["number"] == 1)
    assert seat1_after["status"] == "available", "hold should have expired and seat become available"